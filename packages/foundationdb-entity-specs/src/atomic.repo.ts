// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { Subspace, Watch, RangeOptions } from '@openland/foundationdb';
// @ts-ignore
import { EntityStorage, BaseStore, codecs as c } from '@openland/foundationdb-entity';
// @ts-ignore
import { AtomicIntegerFactory, AtomicBooleanFactory } from '@openland/foundationdb-entity';

export class SimpleAtomicBooleanFactory extends AtomicBooleanFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('simpleAtomicBoolean');
        return new SimpleAtomicBooleanFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(key: string) {
        return this._findById([key]);
    }

    get(ctx: Context, key: string) {
        return this._get(ctx, [key]);
    }

    set(ctx: Context, key: string, value: boolean) {
        return this._set(ctx, [key], value);
    }

    invert(ctx: Context, key: string) {
        return this._invert(ctx, [key]);
    }
}

export class SimpleAtomicIntegerFactory extends AtomicIntegerFactory {

    static async open(storage: EntityStorage) {
        let directory = await storage.resolveAtomicDirectory('simpleAtomicInteger');
        return new SimpleAtomicIntegerFactory(storage, directory);
    }

    private constructor(storage: EntityStorage, subspace: Subspace) {
        super(storage, subspace);
    }

    byId(key: string) {
        return this._findById([key]);
    }

    get(ctx: Context, key: string) {
        return this._get(ctx, [key]);
    }

    set(ctx: Context, key: string, value: number) {
        return this._set(ctx, [key], value);
    }

    add(ctx: Context, key: string, value: number) {
        return this._add(ctx, [key], value);
    }

    increment(ctx: Context, key: string) {
        return this._increment(ctx, [key]);
    }

    decrement(ctx: Context, key: string) {
        return this._decrement(ctx, [key]);
    }
}

export interface Store extends BaseStore {
    readonly SimpleAtomicBoolean: SimpleAtomicBooleanFactory;
    readonly SimpleAtomicInteger: SimpleAtomicIntegerFactory;
}

export async function openStore(storage: EntityStorage): Promise<Store> {
    let SimpleAtomicBooleanPromise = SimpleAtomicBooleanFactory.open(storage);
    let SimpleAtomicIntegerPromise = SimpleAtomicIntegerFactory.open(storage);
    return {
        storage,
        SimpleAtomicBoolean: await SimpleAtomicBooleanPromise,
        SimpleAtomicInteger: await SimpleAtomicIntegerPromise,
    };
}
