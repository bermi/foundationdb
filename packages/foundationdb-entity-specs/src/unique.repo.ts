// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { Subspace, Watch, RangeOptions } from '@openland/foundationdb';
// @ts-ignore
import { EntityStorage, BaseStore, codecs as c } from '@openland/foundationdb-entity';
// @ts-ignore
import { Entity, EntityFactory, EntityDescriptor, SecondaryIndexDescriptor, ShapeWithMetadata, PrimaryKeyDescriptor, FieldDescriptor } from '@openland/foundationdb-entity';

export interface UniqueIndexShape {
    id: number;
    unique1: string;
    unique2: string;
}

export interface UniqueIndexCreateShape {
    unique1: string;
    unique2: string;
}

export class UniqueIndex extends Entity<UniqueIndexShape> {
    get id(): number { return this._rawValue.id; }
    get unique1(): string { return this._rawValue.unique1; }
    set unique1(value: string) {
        let normalized = this.descriptor.codec.fields.unique1.normalize(value);
        if (this._rawValue.unique1 !== normalized) {
            this._rawValue.unique1 = normalized;
            this._updatedValues.unique1 = normalized;
            this.invalidate();
        }
    }
    get unique2(): string { return this._rawValue.unique2; }
    set unique2(value: string) {
        let normalized = this.descriptor.codec.fields.unique2.normalize(value);
        if (this._rawValue.unique2 !== normalized) {
            this._rawValue.unique2 = normalized;
            this._updatedValues.unique2 = normalized;
            this.invalidate();
        }
    }
}

export class UniqueIndexFactory extends EntityFactory<UniqueIndexShape, UniqueIndex> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('uniqueIndex');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        secondaryIndexes.push({ name: 'test', storageKey: 'test', type: { type: 'unique', fields: [{ name: 'unique1', type: 'string' }, { name: 'unique2', type: 'string' }] }, subspace: await storage.resolveEntityIndexDirectory('uniqueIndex', 'test') });
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'unique1', type: { type: 'string' }, secure: false });
        fields.push({ name: 'unique2', type: { type: 'string' }, secure: false });
        let codec = c.struct({
            id: c.integer,
            unique1: c.string,
            unique2: c.string,
        });
        let descriptor: EntityDescriptor<UniqueIndexShape> = {
            name: 'UniqueIndex',
            storageKey: 'uniqueIndex',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new UniqueIndexFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<UniqueIndexShape>) {
        super(descriptor);
    }

    readonly testIndex = Object.freeze({
        find: async (ctx: Context, unique1: string, unique2: string) => {
            return this._findFromUniqueIndex(ctx, [unique1, unique2], this.descriptor.secondaryIndexes[0]);
        }
    });

    create(ctx: Context, id: number, src: UniqueIndexCreateShape): Promise<UniqueIndex> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({ id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<UniqueIndex | null> {
        return this._findById(ctx, [id]);
    }

    watch(ctx: Context, id: number): Watch {
        return this._watch(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<UniqueIndexShape>): UniqueIndex {
        return new UniqueIndex([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface Store extends BaseStore {
    readonly UniqueIndex: UniqueIndexFactory;
}

export async function openStore(storage: EntityStorage): Promise<Store> {
    let UniqueIndexPromise = UniqueIndexFactory.open(storage);
    return {
        storage,
        UniqueIndex: await UniqueIndexPromise,
    };
}
