// THIS FILE IS AUTOGENERATED! DO NOT TRY TO EDIT!
// @ts-ignore
import { Context } from '@openland/context';
// @ts-ignore
import { Subspace } from '@openland/foundationdb';
// @ts-ignore
import { EntityStorage, BaseStore, codecs as c } from '@openland/foundationdb-entity';
// @ts-ignore
import { Entity, EntityFactory, EntityDescriptor, SecondaryIndexDescriptor, ShapeWithMetadata, PrimaryKeyDescriptor, FieldDescriptor } from '@openland/foundationdb-entity';

export interface SimpleEntityShape {
    id: string;
    value: string;
    value2: number;
    value3: boolean | null;
}

export interface SimpleEntityCreateShape {
    value: string;
    value2: number;
    value3?: boolean | null | undefined;
}

export class SimpleEntity extends Entity<SimpleEntityShape> {
    get id(): string { return this._rawValue.id; }
    get value(): string {  return this._rawValue.value; }
    set value(value: string) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
    get value2(): number {  return this._rawValue.value2; }
    set value2(value: number) {
        let normalized = this.descriptor.codec.fields.value2.normalize(value);
        if (this._rawValue.value2 !== normalized) {
            this._rawValue.value2 = normalized;
            this._updatedValues.value2 = normalized;
            this.invalidate();
        }
    }
    get value3(): boolean | null { return this._rawValue.value3; }
    set value3(value: boolean | null) {
        let normalized = this.descriptor.codec.fields.value3.normalize(value);
        if (this._rawValue.value3 !== normalized) {
            this._rawValue.value3 = normalized;
            this._updatedValues.value3 = normalized;
            this.invalidate();
        }
    }
}

export class SimpleEntityFactory extends EntityFactory<SimpleEntityShape, SimpleEntity> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('simpleEntity');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'string' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: 'string', nullable: false, secure: false });
        fields.push({ name: 'value2', type: 'integer', nullable: false, secure: false });
        fields.push({ name: 'value3', type: 'boolean', nullable: true, secure: false });
        let codec = c.struct({
            id: c.string,
            value: c.string,
            value2: c.number,
            value3: c.optional(c.boolean),
        });
        let descriptor: EntityDescriptor<SimpleEntityShape> = {
            name: 'SimpleEntity',
            storageKey: 'simpleEntity',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new SimpleEntityFactory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<SimpleEntityShape>) {
        super(descriptor);
    }

    create(ctx: Context, id: string, src: SimpleEntityCreateShape): Promise<SimpleEntity> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({id, ...src }));
    }

    findById(ctx: Context, id: string): Promise<SimpleEntity | null> {
        return this._findById(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<SimpleEntityShape>): SimpleEntity {
        return new SimpleEntity([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface SimpleEntity2Shape {
    id: number;
    value: string;
}

export interface SimpleEntity2CreateShape {
    value: string;
}

export class SimpleEntity2 extends Entity<SimpleEntity2Shape> {
    get id(): number { return this._rawValue.id; }
    get value(): string {  return this._rawValue.value; }
    set value(value: string) {
        let normalized = this.descriptor.codec.fields.value.normalize(value);
        if (this._rawValue.value !== normalized) {
            this._rawValue.value = normalized;
            this._updatedValues.value = normalized;
            this.invalidate();
        }
    }
}

export class SimpleEntity2Factory extends EntityFactory<SimpleEntity2Shape, SimpleEntity2> {

    static async open(storage: EntityStorage) {
        let subspace = await storage.resolveEntityDirectory('simpleEntity2');
        let secondaryIndexes: SecondaryIndexDescriptor[] = [];
        let primaryKeys: PrimaryKeyDescriptor[] = [];
        primaryKeys.push({ name: 'id', type: 'integer' });
        let fields: FieldDescriptor[] = [];
        fields.push({ name: 'value', type: 'string', nullable: false, secure: false });
        let codec = c.struct({
            id: c.number,
            value: c.string,
        });
        let descriptor: EntityDescriptor<SimpleEntity2Shape> = {
            name: 'SimpleEntity2',
            storageKey: 'simpleEntity2',
            subspace, codec, secondaryIndexes, storage, primaryKeys, fields
        };
        return new SimpleEntity2Factory(descriptor);
    }

    private constructor(descriptor: EntityDescriptor<SimpleEntity2Shape>) {
        super(descriptor);
    }

    create(ctx: Context, id: number, src: SimpleEntity2CreateShape): Promise<SimpleEntity2> {
        return this._create(ctx, [id], this.descriptor.codec.normalize({id, ...src }));
    }

    findById(ctx: Context, id: number): Promise<SimpleEntity2 | null> {
        return this._findById(ctx, [id]);
    }

    protected _createEntityInstance(ctx: Context, value: ShapeWithMetadata<SimpleEntity2Shape>): SimpleEntity2 {
        return new SimpleEntity2([value.id], value, this.descriptor, this._flush, ctx);
    }
}

export interface Store extends BaseStore {
    readonly SimpleEntity: SimpleEntityFactory;
    readonly SimpleEntity2: SimpleEntity2Factory;
}

export async function openStore(storage: EntityStorage): Promise<Store> {
    let SimpleEntityPromise = SimpleEntityFactory.open(storage);
    let SimpleEntity2Promise = SimpleEntity2Factory.open(storage);
    return {
        storage,
        SimpleEntity: await SimpleEntityPromise,
        SimpleEntity2: await SimpleEntity2Promise,
    };
}
